#include <iostream>
#include "queue.h"

// disruptor核心思想
/*
    之前的实现思路中，队列只支持两个操作，添加数据和读取并移除数据，
    分别对应代码中的add()函数和poll()函数，而Disruptor采用了另
    一种实现思路。

    对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，
    并且是批量地申请连续的n个（n≥1）存储单元。当申请到这组连续的存
    储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储
    单元是这个线程独享的。不过，从刚刚的描述中，我们可以看出，申请存
    储单元的过程是需要加锁的。对于消费者来说，处理的过程跟生产者是类
    似的。它先去申请一批连续可读的存储单元（这个申请的过程也是需要加
    锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了

    不过，还有一个需要特别注意的地方，那就是，如果生产者A申请到了一组
    连续的存储单元，假设是下标为3到6的存储单元，生产者B紧跟着申请到了
    下标是7到9的存储单元，那在3到6没有完全写入数据之前，7到9的数据是无
    法读取的。这个也是Disruptor实现思路的一个弊端
*/

int main() {
    Queue queue(2);
    std::cout << queue.add(5) << std::endl;

    long x;
    auto ret = queue.poll(x);

    std::cout << "ret = " << ret << ", x = " << x << std::endl;
    
    return 0;
}